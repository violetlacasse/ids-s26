---
title: Chapter 3 "Database operation with Structured Query Language (SQL)"
subtitle: "Introduction to Data Science | Spring 2026"
author: "Shreya Sudarsanam"
format: html
---
# 3.0 Welcome!
Welcome to Database Operation with Structured Query Language (SQL)!

# 3.1.1 How To Use SQL In Python With Pandas Using a SQL-Created Table 

* First, we will import pandas
* Then, we will import sqlite3

```{python}
import pandas as pd
import sqlite3
```

* Next, we will create a connection to a sql database using the command, 
sqlite3.connect("name_of_database"), and store this in a variable.

```{python}
sql_database_connection = sqlite3.connect(':memory:')
```

* Now, we will explore the cursor.() command:

```{python}
#A cursor variable will be created that will help run all SQL queries
cursor = sql_database_connection.cursor()
#Executes the SQL query to create the table
cursor.execute('CREATE TABLE lemon_types_new (organic_or_not TEXT, GMO_or_NOT TEXT)')
#Executes the SQL query to insert into the table
cursor.execute('INSERT INTO lemon_types_new VALUES ("Yes", "Yes")')
```

* To store your sql query, create a variable.

```{python}
sql_query = """SELECT * FROM lemon_types_new"""
```

* To execute the sql_query, create a data frame using pandas. Then, use the function, .read_sql_query, to read the sql_query. The two arguments of the function are the sql_query and the sql_database_connection.

```{python}
pandas_data_frame = pd.read_sql_query(sql_query, sql_database_connection)
print(pandas_data_frame)
```

# 3.1.2 How To Use SQL In Python With Pandas Data Frame

* First, we will import pandas
* Then, we will import sqlite3

```{python}
import pandas as pd
import sqlite3
```

* Next, we create a pandas data frame with stored values:
```{python}
pandas_data_frame_with_values = pd.DataFrame({"owners_of_lemonade_stands": ["Kathy", "Lily", "Lavender", "Samantha", "Rose", "Rebecca"],
                                              "week_one_sales_dollars": [100, 120, 300, 650, 200, 210],
                                              "week_two_sales_dollars": [120, 140, 380, 780, 220, 260],
                                              "week_three_sales_dollars": [20, 40, 80, 100, 50, 60],
                                              "week_four_sales_dollars": [200, 240, 600, 1310, 400, 420],
                                              "temperature_degrees_fareheit": [60, 70, 30, 80, 100, 120]})
```

* Next, We will create a connection to a sql database using the command, 
sqlite3.connect("name_of_database"), and store this in a variable.

```{python}
sql_database_connection = sqlite3.connect("lemonade_stand_business.db")
```

Important note: If the database has not been created yet, the sqlite3.connect() command will create a new database.

* "To convert the data frame to a table in sql, use the command, df.to_sql().
This command should have THREE arguments:

  * The first argument is name, which specifies the name of the dataframe. 

  * The second argument is con, which specifies the connection to a specific database. 

  * The third argument, which is optional, is if_exists=REPLACE. This argument makes sure that if there are two sql tables with the same name, the older sql tale will be replaced by the newer sql table. 

* The last argument, whcih is also optional, is index = (TRUE, FALSE). If index = TRUE, this creates a numerical index for the data frame. However, if index = FALSE, there will be no numerical index applied to the data frame.

```{python}
pandas_data_frame_with_values.to_sql("lemonade_stand_data", sql_database_connection, if_exists="replace", index=True)
```

* To store your sql query, create a variable.

```{python}
sql_query_new = """SELECT * from lemonade_stand_data"""
```

* To create a data frame that captures a view of your original SQL table,
create a new data frame variable, and apply the .read_sql_query() function:

```{python}
data_frame_select_all = pd.read_sql_query(sql_query_new, sql_database_connection)
print(data_frame_select_all)
```

# 3.1.3 Different Ways To Establish SQL Database Connections 

SQL Database Connections can be establish two ways: You can either:
 * create a temporary database in memory
 * or you can create a named database.

Example of creating a temporary database in memory:
```{python}
sql_database_connection = sqlite3.connect(':memory:')
```

Example of creating a named database that can be saved:
```{python}
sql_database_connection = sqlite3.connect("lemonade_stand_business.db")
```

# 3.1.4 How To Use SQLite 3 In Python Without Pandas 

* Import sqlite3
```{python}
import sqlite3
```

* Establish connection to a sql database. The following example establishes a 
connection to a temporary, in-memory database:
```{python}
sql_database_connection = sqlite3.connect(':memory:')
```

* Next, create an object, called cursor, to run SQL queries.
This object is a variable that represents the .cursor() attribute of 
the sql database connection.

```{python}
cursor = sql_database_connection.cursor()
```

* Afterwards, execute a SQL command using cursor.execute("SQL command")

```{python}
cursor.execute('CREATE TABLE new_lemonade_stand (owner TEXT, weekly_sales_avg INT)')
```

  * Creates a table named lemonade_stand
  * The table has columns named owner and weekly_sales_avg
  * The data type for the owner column is TEXT
  * The data type for the weekly_sales_avg column is INT

```{python}
cursor.execute('INSERT INTO new_lemonade_stand VALUES ("Lavender", 300)')
```

 * Adds data to the lemonade_stand table, using the command, INSERT INTO

* It is important to save any alterations to the database by using a
special sql_database_connection.commit() command.

```{python}
sql_database_connection.commit()
```

* To view the result of a SQL query, it is necessary to perform the cursor.fetchall() function:
```{python}
cursor.execute('SELECT * FROM new_lemonade_stand')
sql_table_result = cursor.fetchall()
print(sql_table_result)
```

# 3.1.5 How to display cursor.fetchall() results in a pandas data frame

```{python}
cursor.execute('SELECT * FROM new_lemonade_stand')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

# 3.2.1 Types of Commands In SQL

## Data Definition Language (DDL): 
* 1. SQL statements that name, change the structuer of, and 
eliminate objects in a database

## Data Control Language (DCL):
* 2. SQL statements that control who has access to 
database data.

## Data Manipulation Language (DML):
* 3. SQL statements that do not impact database structure.
Instead, these statements change/access objects inside a database.

## Data Transaction Control (DTC):
* 4.Track how Data Manipulation Language commands
change objects in a database by logging these
changes as transactions.

# 3.2.2 Exploring Types of Data Manipulation Language (DML) Commands
* 1. Selection: Involves selecting specific rows from a table
* 2. Projection: Involves selecting specific columns from a table
* 3. Joining: Involves joining tables together

## Exploring SELECTION with organic_lemonade_stand data table:

The below code helps create the organic_lemonade_stand data table:
```{python}
cursor.execute('CREATE TABLE organic_lemonade_stand (owner TEXT, location TEXT, weekly_expenses_avg INT, weekly_sales_avg INT)')
cursor.execute('INSERT INTO organic_lemonade_stand VALUES ("Lily", "Florida", 100, 500)')
cursor.execute('INSERT INTO organic_lemonade_stand VALUES ("Summer", "California", 300, 800)')
cursor.execute('INSERT INTO organic_lemonade_stand VALUES ("Layla", "New York", 200, 250)')
cursor.execute('INSERT INTO organic_lemonade_stand VALUES ("Beatrice", "Alaska", 50, 60)')
cursor.execute('INSERT INTO organic_lemonade_stand VALUES ("Carla", "Massachusetts", 250, 300)')
sql_database_connection.commit()
```

The below code helps select all rows in the organic_lemonade_stand data table:

```{python}
cursor.execute('SELECT * FROM organic_lemonade_stand')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

## Exploring PROJECTION with organic_lemonade_stand database
The owner column is being selected
```{python}
cursor.execute('SELECT owner FROM organic_lemonade_stand')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

## Exploring SELECTION & PROJECTION combined
The owner column is being selected (projection), and rows where weekly_expenses_avg is greater than 100 is also selected (selection).

```{python}
cursor.execute('SELECT owner, weekly_expenses_avg FROM organic_lemonade_stand WHERE weekly_expenses_avg > 100')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

## Exploring JOINING with organic_lemonade_stand data table and sparkling_lemon_water data table

The below code creates the sparkling_lemon_water data table:
```{python}
cursor.execute('CREATE TABLE sparkling_lemon_water (owner TEXT, location TEXT, weekly_expenses_avg INT, weekly_sales_avg INT)')
cursor.execute('INSERT INTO sparkling_lemon_water VALUES ("Daisy", "Florida", 20, 65)')
cursor.execute('INSERT INTO sparkling_lemon_water VALUES ("Kathy", "California", 65, 160)')
cursor.execute('INSERT INTO sparkling_lemon_water VALUES ("Samantha", "New York", 85, 280)')
cursor.execute('INSERT INTO sparkling_lemon_water VALUES ("Samantha", "New York", 85, 280)')
sql_database_connection.commit()
```

### INNER JOIN: A type of SQL join where rows that are common in both tables are presented in the output.

```{python}
cursor.execute('SELECT * FROM organic_lemonade_stand INNER JOIN sparkling_lemon_water ON organic_lemonade_stand.location = sparkling_lemon_water.location')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

### LEFT JOIN: A type of SQL join where every row in the left table is shown in the output, along with rows in the right table that match the left table 

```{python}
cursor.execute('SELECT * FROM organic_lemonade_stand LEFT JOIN sparkling_lemon_water ON organic_lemonade_stand.location = sparkling_lemon_water.location')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

### RIGHT JOIN: A type of SQL join where every row in the right table is shown in the output, along withh rows in the left table that match the right table.

```{python}
cursor.execute('SELECT * FROM organic_lemonade_stand RIGHT JOIN sparkling_lemon_water ON organic_lemonade_stand.location = sparkling_lemon_water.location')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

# 3.2.3 USING ALIASES IN DML STATEMENTS

To reference a table, it may be easier to "alias" the table or shorten the table's name, to make the code more readable. Below is the JOINING command, but with table aliases:

```{python}
cursor.execute('SELECT * FROM organic_lemonade_stand lemon INNER JOIN sparkling_lemon_water sparkling ON lemon.location = sparkling.location')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

# 3.2.4 USING DISTINCT IN DML
The sparkling_lemon_water contains duplicate rows for the owner, Samantha.
To only return one distinct row, we need to use the DISTINCT command.

```{python}
cursor.execute('SELECT DISTINCT owner, location, weekly_expenses_avg, weekly_sales_avg FROM sparkling_lemon_water')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

# 3.2.5 LOGICAL OPERATORS 
* 1. AND: If both conditions are TRUE, the entire expression is TRUE
* 2. OR: If at least one condition is TRUE, the entire expression is TRUE
* 3. NOT: Returns TRUE if NOT FALSE, and Returns FALSE if NOT TRUE

## Example of AND - LOGICAL OPERATORS
```{python}
cursor.execute('SELECT * FROM organic_lemonade_stand WHERE weekly_expenses_avg < 300 AND weekly_sales_avg > 200')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

## Example of OR - LOGICAL OPERATORS
```{python}
cursor.execute('SELECT * FROM organic_lemonade_stand WHERE weekly_expenses_avg < 300 OR weekly_sales_avg > 500')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

## Example of NOT - LOGICAL OPERATORS
```{python}
cursor.execute('SELECT * FROM organic_lemonade_stand WHERE NOT weekly_expenses_avg < 100')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

# 3.2.6 ARITHMETIC OPERATORS
We can create a new alias, weekly_profits_avg, by subtracting
the weekly_expenses_avg column from the weekly_sales_column, using arithmetic
operators.

```{python}
cursor.execute('SELECT weekly_sales_avg - weekly_expenses_avg AS weekly_profits_avg FROM organic_lemonade_stand')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

# 3.2.7 CONCATENATION OPERATORS
We can concatenate two columns together using a special concatenation operator:
```{python}
cursor.execute("SELECT owner||': '||location AS 'owner location' FROM organic_lemonade_stand")
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

In this example, the owner and location columns are being concatenated to form the owner location column.

# 3.2.8 ORDER BY AND DESC
We can find what owner is the most profitable by using the ORDER BY operator.
ORDER BY always orderes entries from least to greatest. However, ORDER BY (insert name of column) DESC to order the columns from greatest to least.

ORDER BY Example:
```{python}
cursor.execute('SELECT * FROM organic_lemonade_stand ORDER BY weekly_expenses_avg')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

ORDER BY DESC Example:
```{python}

cursor.execute('SELECT * FROM organic_lemonade_stand ORDER BY weekly_expenses_avg DESC')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

# 3.2.9 SET OPERATORS
* 1. UNION: Produces a set combining outputs created by 2 SELECT queries. 
Any rows that are duplicated are not part of the resulting set.

* 2. UNION ALL: Similar to UNION, this produces a set combining outputs
created by 2 SELECT queries. However, any rows that are duplicated are
displayed in the resulting set.

* 3. INTERSECT: Finds rows that are shared by both tables/SELECT queries.
The output contains distinct rows.

* 4. MINUS/EXCEPT: Finds rows that the first SELECT query has but the second
SELECT query  does not have. These rows are distinct. Note that MINUS is not
compatible with SQLITE, and is only compatible with ORACLE

Below is code that creates the numerical_data table:
```{python}
cursor.execute('CREATE TABLE numerical_data (numbers INT)')
cursor.execute('INSERT INTO numerical_data VALUES (1)')
cursor.execute('INSERT INTO numerical_data VALUES (1)')
cursor.execute('INSERT INTO numerical_data VALUES (1)')
cursor.execute('INSERT INTO numerical_data VALUES (2)')
cursor.execute('INSERT INTO numerical_data VALUES (3)')
cursor.execute('INSERT INTO numerical_data VALUES (4)')
cursor.execute('INSERT INTO numerical_data VALUES (10)')
```

Below is code that creates the cool_numbers_data table:

```{python}
cursor.execute('CREATE TABLE cool_numbers_data (cool_numbers INT)')
cursor.execute('INSERT INTO cool_numbers_data VALUES (1)')
cursor.execute('INSERT INTO cool_numbers_data VALUES (2)')
cursor.execute('INSERT INTO cool_numbers_data VALUES (3)')
cursor.execute('INSERT INTO cool_numbers_data VALUES (4)')
cursor.execute('INSERT INTO cool_numbers_data VALUES (5)')
```

Example of the UNION OPERATOR:
Finds the union of the data tables, numerical_data and cool_numbers_data:

```{python}
cursor.execute('SELECT numbers FROM numerical_data UNION SELECT cool_numbers FROM cool_numbers_data')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

Example of the UNION ALL OPERATOR:
Finds the UNION ALL of the data tables, numerical_data and cool_numbers_data:

```{python}
cursor.execute('SELECT numbers FROM numerical_data UNION ALL SELECT cool_numbers FROM cool_numbers_data')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

Example of the INTERSECT OPERATOR:
Finds the intersection of the data tables, numerical_data and cool_numbers_data:

```{python}

cursor.execute('SELECT numbers FROM numerical_data INTERSECT SELECT cool_numbers FROM cool_numbers_data')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

Example of the EXCEPT OPERATOR:
Finds the execption of the data tables, numerical_data and cool_numbers_data:

```{python}
cursor.execute('SELECT numbers FROM numerical_data EXCEPT SELECT cool_numbers FROM cool_numbers_data')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

# 3.3.0 SUBQUERIES
* Subqueries are smaller queries within a larger query. When subqueries are evaluated, they help filter the data, and this filter can applied to the larger query.

## TWO TYPES OF SUBQUERIES
* The two types of subqueries are Inline Views and Nested Subqueries

### Inline Views
* When a SELECT statement has a FROM cause that contains a subquery, this is
called an Inline View.

Example:
```{python}
cursor.execute('SELECT owner, weekly_sales_avg, weekly_profit_avg/5 AS daily_profit_avg FROM (SELECT owner, weekly_sales_avg, weekly_sales_avg - weekly_expenses_avg AS weekly_profit_avg FROM organic_lemonade_stand) ORDER BY daily_profit_avg')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

### Nested Subquery
* When a SELECT statement has a WHERE clause that contains a subquery, this is
called a Nested Subquery.

Example 1:
```{python}
cursor.execute('SELECT owner, weekly_expenses_avg, weekly_sales_avg FROM organic_lemonade_stand WHERE weekly_sales_avg > (SELECT weekly_sales_avg FROM sparkling_lemon_water)')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```


Example 2:
```{python}
cursor.execute('SELECT owner, weekly_expenses_avg, weekly_sales_avg FROM organic_lemonade_stand WHERE weekly_sales_avg < (SELECT weekly_sales_avg FROM sparkling_lemon_water)')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

## CLASSES OF SUBQUERIES
* Subqueries can be categorized further into three classes.
* The three classes of Subqueries are as follows: Single-row subqueries, Multiple-row subqueries, and Correlated subqueries

### SINGLE ROW SUBQUERIES
1. Single-row subqueries: Subqueries that output a single row, which is then evaluated by the outer query

Example:
```{python}
cursor.execute('SELECT owner, weekly_sales_avg, weekly_expenses_avg FROM organic_lemonade_stand WHERE weekly_expenses_avg <= 300 AND weekly_sales_avg > (SELECT AVG(weekly_sales_avg) AS mean_of_weekly_sales_avg FROM organic_lemonade_stand)')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

### MULTIPLE-ROW SUBQUERIES
* 2. Multiple-row subqueries: Subqueries that output many rows, which are then evluated by the outer query

Example:
```{python}
cursor.execute('CREATE TABLE successful_organic_business_owners (successful_owner_name TEXT, weekly_revenue INT)')
sql_database_connection.commit()

cursor.execute('INSERT INTO successful_organic_business_owners SELECT owner, weekly_sales_avg - weekly_expenses_avg AS weekly_profits_avg FROM organic_lemonade_stand WHERE weekly_sales_avg - weekly_expenses_avg > 200')
cursor.execute('SELECT * FROM successful_organic_business_owners')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

### Correlated Subqueries
* 3. Correlated subqueries: Subqueries that depend on the outer query because they reference column information from the outer query

Example:
```{python}
cursor.execute('SELECT weekly_sales_avg FROM organic_lemonade_stand WHERE weekly_sales_avg > (SELECT weekly_sales_avg FROM sparkling_lemon_water WHERE organic_lemonade_stand.weekly_expenses_avg > sparkling_lemon_water.weekly_expenses_avg)')
rows_fetched = cursor.fetchall()
columns_fetched = [metadata_description[0] for metadata_description in cursor.description]
data_frame_fetched = pd.DataFrame(rows_fetched, columns=columns_fetched)
print(data_frame_fetched)
```

# 3.3.1 Data Visualization Using SQL

How to Present SQL table result using matplotlib:

* First, import matplotlib
```{python}
import matplotlib.pyplot as plt
```

* Create a SQL query that you would like to visualize via matplotlib
```{python}
data_frame_to_be_visualized = pd.read_sql_query("""SELECT location, weekly_expenses_avg FROM organic_lemonade_stand""", sql_database_connection)
print(data_frame_to_be_visualized)
```

* Use matplotlib commands to construct and display the appropriate visual:
```{python}
plt.bar(data_frame_to_be_visualized["location"], data_frame_to_be_visualized["weekly_expenses_avg"])
plt.xlabel("Location")
plt.ylabel("Average Weekly Expenses")
plt.title("Average Weekly Expenses by Location")
plt.show()
```

# 3.3.2 How to Close a SQL Database Connection
```{python}
sql_database_connection.close()
```

# Further Resources:
## Books:
 * Oracle Database 12C SQL by Matthew Morris
 * Geeks for Geeks SQL Manual
 * Learning SQL by Alan Beaulieu
 
## Websites:
 * https://www.geeksforgeeks.org/python/python-sqlite-connecting-to-database/
 * https://docs.python.org/3/library/sqlite3.html
 * https://datacarpentry.github.io/python-ecology-lesson/instructor/09-working-with-sql.html
 * https://www.geeksforgeeks.org/python/python-sqlite/
 * https://datacarpentry.github.io/python-socialsci/instructor/14-sqlite.html















